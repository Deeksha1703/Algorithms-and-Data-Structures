import itertools
def best_revenue(revenue, travel_days, start):
	"""
	Function that returns the maximum possible revenue that the salesperson can generate
	Precondition: 
        - Revenue that can be made on each day in each city needs to be known
    Postcondition:
        - Maximum possible revenue is returned
    Input:
        - revenue: revenue[z][x] is the revenue that the salesperson would make if they worked in city x on day z
		- travel_days: travel_days[x][y] will contain either apositive integer number indicating the number of days you need to spend to travel on 
					 the direct road from city x to city y or -1, to indicate that there is no direct road for you to travel from city x to city y.
        - start: city that the salesperson starts in on day 0
    Return:
        - after_travel: The maximum possible revenue that can be generated by the salesperson
    Time complexity: 
        Best: O(nd)
        Worst: O(n^2(d+n))
    Space complexity: 
        Input: O(nd)
        Aux: O(nd)
	n -> Number of cities
	d -> Number of days
	"""
	if len(revenue) == 0 or len(travel_days) == 0:
		return 0

	# Storing the highest amount of money that the salesperson make in a particular day and city before he starts travelling and after
	after_travel = []
	before_travel = []

	# Put a list of city and set all their default values to 1 every day
	for _ in range(len(revenue)):
		after_travel.append([-1] * len(travel_days))
		before_travel.append([-1] * len(travel_days))

	for day, city in itertools.product(range(len(revenue) - 1, -1, -1), range(len(travel_days))):
		if day == len(revenue) - 1:
			after_travel[day][city] = revenue[day][city]
			before_travel[day][city] = revenue[day][city] if (travel_days[city] == 0) else 0
		else:
			# checking the 3 directions that the salesperson can travel to
			if after_travel[day+1][city] + revenue[day][city] > after_travel[day][city]:
				after_travel[day][city] = after_travel[day+1][city] + revenue[day][city]
			if len(revenue) - day <= travel_days[city][0]:
				before_travel[day][city] = 0
			elif before_travel[day][city] < after_travel[day + travel_days[1][city]][city]:
				before_travel[day][city] = after_travel[day + travel_days[1][city]][city]

			# travelling to the city on the left if it isn't the leftmost city
			if city != 0:
				if before_travel[day + 1][city - 1] > after_travel[day][city]:
					after_travel[day][city] = before_travel[day + 1][city - 1]
				if before_travel[day + 1][city - 1] > before_travel[day][city]:
					before_travel[day][city] = before_travel[day + 1][city - 1]

			# travelling to the city on the right if it isn't the rightmost city
			if city != len(travel_days) - 1:
				if before_travel[day + 1][city + 1] > after_travel[day][city]:
					after_travel[day][city] = before_travel[day + 1][city + 1]
				if before_travel[day + 1][city + 1] > before_travel[day][city]:
					before_travel[day][city] = before_travel[day + 1][city + 1]

	# Returning the maximum revenue that the salesperson can make
	return after_travel[0][start]


def hero(attacks):
	"""
	Function that returns a list of Master X attacks that Dr Weird will attend to, that will result in the most Master X clones defeated
	Precondition: 
        - attacks list in non empty
		- Dr.Weird will always defeat the clones
    Postcondition:
        - List of Master X attacks that Dr Weird will attend to, that will result in the most Master X clones defeated is returned
    Input:
        - attacks: A non-empty list of N attacks, where each attack is a list of 4 items [m, s, e, c]: 
			• m is the multiverse which Master X is attacking.
			• s and e are the starting and ending days of the attack.
			• c is the number of Master X clones in the attack.
    Return:
        - final_attacks: List of Master X attacks that Dr Weird will attend to, to result in the most Master X clones defeated
    Time complexity: 
        Best: O(N)
        Worst: O(NlogN)
    Space complexity: 
        Input: O(N)
        Aux: O(N)
	N -> Number of attacks in the attacks list
	"""
	clones = []
	possible_attacks = []
	successful_attacks = []
	# looping through the attacks list
	for i in range(len(attacks)):
		# number of master X clones in the attack
		attack_clones = attacks[i][3]

		# looping through the attacks list
		for j in range(len(attacks)):
			if attacks[i][2] < attacks[j][1]:
				successful_attacks.append(attacks[j])
				attack_clones += attacks[j][3]
				successful_attacks.append(attacks[i])
				clones.append(attack_clones)
				possible_attacks.append(successful_attacks)

	# finding index of optimal attacks to defeat maximum number of clones
	maxClone_index = clones.index(max(clones))
	final_attacks = possible_attacks[maxClone_index]
	return final_attacks

if __name__ == "__main__":
	# TEST CASES FOR best_revenue(revenue,travel_days,start) FUNCTION

	# test case 1
	# Expected output = 30
	# Actual output = 30
	travel_days = [[-1,-1, 3, 1], 
                       [-1,-1,-1, 1], 
                       [ 1,-1,-1, 1], 
                       [ 1, 1, 2,-1]] 
        
	revenue =     [[ 1,    2, 3, 4], 
                       [ 3,    6, 1, 5], 
                       [ 1,    8, 4, 1], 
                       [ 1,   10, 4, 5], 
                       [10,    4, 5, 9]] 
	start = 1
	print(best_revenue(revenue, travel_days, start))

	# test case 2
	# Expected output = 16
	# Actual output = 16
	travel_days = [[-1,-1, 3, 1],
                    [-1,-1,-1, 1],
                    [ 1,-1,-1, 1],
                    [ 1, 1, 2,-1]]
        
	revenue =     [[ 1,    2, 3, 4], 
                	[ 3,    6, 1, 5], 
                    [ 1,    8, 4, 1], 
                    [ 1,   10, 4, 5],
                    [10,    4, 5, 9]]
	start = 0

	print(best_revenue(revenue, travel_days, start))

	# test case 3
	# Expected output = 102
	# Actual output = 100
	travel_days = [[-1,  1,  1],  
                       [ 1, -1,  1],  
                       [ 1,  2, -1]]  
	revenue = [[1, 2,   1],   
                   [3, 3,   1],   
                   [1, 1, 100]]   
	start = 1
	print(best_revenue(revenue, travel_days, start))

	# test case 4
	# Expected output = 22
	# Actual output = 17
	travel_days = [[-1,-1, 3, 1], 
                       [-1,-1,-1, 1], 
                       [ 1,-1,-1, 1], 
                       [ 1, 1, 2,-1]] 
        
	revenue =     [[ 1,    2, 3, 4], 
                       [ 3,    6, 1, 5], 
                       [ 1,    8, 4, 1], 
                       [ 1,   10, 4, 5], 
                       [10,    4, 5, 9]] 
	start = 2
	print(best_revenue(revenue, travel_days, start))

	# test case 5
	# Expected output = 28
	# Actual output = 24
	travel_days = [[-1,-1, 3, 1], 
                       [-1,-1,-1, 1], 
                       [ 1,-1,-1, 1], 
                       [ 1, 1, 2,-1]] 
        
	revenue =     [[ 1,    2, 3, 4], 
                       [ 3,    6, 1, 5],
                       [ 1,    8, 4, 1], 
                       [ 1,   10, 4, 5], 
                       [10,    4, 5, 9]] 
	start = 3
	print(best_revenue(revenue, travel_days, start))

	# test case 6
	# Expected output = 101
	# Actual output = 5
	travel_days = [[-1,  1,  1],  
                    [ 1, -1,  1], 
                    [ 1,  2, -1]]  
	revenue = [[1, 2,   1],  
                [3, 3,   1],  
                [1, 1, 100]]  
	start = 0
	print(best_revenue(revenue, travel_days, start))

	# TEST CASES FOR hero(attacks) function

	# test case 1
	# Expected output = [[3, 6, 9, 2], [2, 1, 4, 4]]
	# Actual output = [[3, 6, 9, 2], [2, 1, 4, 4]]
	attacks = [[1, 2, 7, 5], [2, 1, 4, 4], [3, 6, 9, 2]]
	print(hero(attacks))

	# test case 2	
	# Expected output = [[3, 5, 6, 2], [2, 1, 4, 4]]
	# Actual output = [[3, 5, 6, 2], [2, 1, 4, 4]]
	attacks = [[1, 2, 7, 6], [2, 1, 4, 4], [3, 5, 6, 2]]
	print(hero(attacks))

	# test case 3
	# Expected output = [[3, 8, 9, 5], [1, 2, 7, 6]]
	# Actual output = [[3, 8, 9, 5], [1, 2, 7, 6]]
	attacks = [[1, 2, 7, 6], [2, 7, 9, 10], [3, 8, 9, 5]]
	print(hero(attacks))